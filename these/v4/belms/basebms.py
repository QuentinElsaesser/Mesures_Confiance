from v4.graph import graphfrom itertools import combinations# from datetime import datetime# import sysclass BasebmS():    """        index formulas start with 0        index interpretation start woth 1    """    def __init__(self, mat_fs, mat_of, voting_met, vote_para, name_norma, nb_s, nb_f,init_trust=1,truth=[],normalizer=None,trust_s=None,trust_f=None,long=False,gobj=None,sf=None,Gr=None,nbl=0,interp=[],agents=None,formulas=None,relia=None,table=None,maxcons=None,distance=None,agents_ind=None,formulas_chosed=None,dict_all_combi=None):        # dict                # print(formulas_chosed) # liste bool        # print(formulas) # dico start 0 (en string) avec les listes de string comme formules                    self.formulas_chosed = formulas_chosed        self.formulas = dict()        self.formulas_id = dict()        self.formulas_pour_mx = dict()                self.taille_formule_avg = 0        cpt = 0                for i in formulas:            inti = int(i)            self.formulas_pour_mx[inti] = set(formulas[i])            self.formulas[i] = set(formulas[i])            self.formulas_id[str(sorted(self.formulas[i]))] = inti            if self.formulas_chosed[inti]:                self.taille_formule_avg += len(self.formulas[i])                cpt += 1        self.taille_formule_avg = self.taille_formule_avg / cpt                        # print(i, self.formulas[i], self.formulas_id[str(sorted(self.formulas[i]))], self.formulas_chosed[int(i)])        if Gr==None:            # list with 1 if fact is in the truth and 0 if not to create the graph            listtruth = [0 for n in mat_fs]            for i in range(len(self.formulas)):                listtruth[i] = int(str(truth[0]) in self.formulas[str(i)])                        G = graph.Graph(mat_fs=mat_fs, mat_of=mat_of, voting_met=voting_met,                           vote_para=vote_para, name_norma=name_norma,                           nb_s=nb_s, nb_f=nb_f, truth=listtruth, trust_s=trust_s,                          init_trust=init_trust,normalizer=normalizer,                          trust_f=trust_f,long=long,gobj=gobj,sf=sf)        else:            if isinstance(Gr, graph.Graph):                G = Gr            else:                G = Gr.G                            if G.normalizer.name != name_norma:                G.normalizer.name = name_norma        # debug        self.info = []                self.G = G        self.truth = truth        self.nb_literals = nbl        self.len_interpretation = 2**self.nb_literals                if len(interp) == 0:                self.interpretation = list(range(self.len_interpretation))        else:            self.interpretation = interp                    if dict_all_combi == None:            self.dict_all_combi = dict()            taille = (2**self.nb_literals) - 2            if taille <= 0:                taille = 1            str_intp = [str(n) for n in self.interpretation]            for curr_taille in range(1, taille+1):                self.dict_all_combi[curr_taille] = []            for curr_taille in range(1, taille+1):                str_poss, sets_poss = self.all_combinations(str_intp, curr_taille)                self.dict_all_combi[curr_taille] = (str_poss, sets_poss)        else:                     self.dict_all_combi = dict_all_combi                    # self.agents_ind = agents_ind                    self.relia = dict()        self.distance = []        self.table = []        self.agents = []        self.agents_ind = []        self.maxcons = []        self.maxcons_ind = []                self.formulas_good = 0        self.nb_total2 = 0        self.nb_rep = 0        self.avg_score = []                self.tmp_una = []                self.len_croyance_avg = 0        # self.taille_profile_avg = 0                if agents == None:            self.gen_agents()        else:            self.agents = agents            # agents_ind car flemme de changer le nom            self.agents_ind = agents_ind        if maxcons == None:            # print("MAXCONS")            self.maxcons, self.maxcons_ind = self.gen_maxcons(self.formulas_pour_mx)            # print("RES:", self.maxcons)            # for i in range(len(self.maxcons)):            #     # print(i, res_f[i], res[i])            #     print(i, self.maxcons_ind[i], self.maxcons[i], self.maxcons_to_interp(self.maxcons[i]))            # # taille = 0            # lst = []            # dico_nb_enum = dict()            # for i in range(self.len_interpretation):            #     dico_nb_enum[str(i)] = 0            # for indx in self.formulas:                # if self.formulas_chosed[int(indx)]:                #     f = self.formulas[indx]                #     lst.append(f)                #     taille = max(taille, len(f))                    ## nombre de formules max pour un maxcons sur une seule interpretation                    # for intp in f:                    #     dico_nb_enum[intp] += 1            # taille += max(list(dico_nb_enum.values()))            # self.maxcons, self.maxcons_ind = self.gen_3maxcons(lst)            # print("LEN", len(self.maxcons), len(self.maxcons_ind))            # self.table = self.maxcons_ind        else:            self.maxcons = maxcons            self.maxcons_ind = table                    if distance == None:            self.gen_distance()        else:            self.distance = distance            self.answers = []        self.nb_answers = 0                self.nb_true_found = 0        self.nb_total = 0                self.len_maxcons = 0        self.max_len_maxcons = 0        self.min_len_maxcons = -1        self.truth_in_mc = 0                self.unanimous_answers_dico = dict()        self.truth_una = 0        self.distance_una = 0        self.nbi_una = 0                self.rep_intp = []        self.intp_bin = []        self.distance_intp = []            def all_combinations(self, lst, taille):        res = []        r = []        for n in combinations(lst, taille):            res.append(list(n))            r.append(set(n))        return res, r            def gen_distance(self):        distance1 = []        distance2 = []        distance3 = []        for j in range(len(self.maxcons)):            # m = self.maxcons[j]            dist1 = 0            dist2 = 0            dist3 = 0            interp = self.maxcons_to_interp(self.maxcons[j])            for i in range(len(self.agents)):                # toutes les formules ou sur l'intersection des formules                for fa in self.agents_to_interp(self.agents[i]):                # for fa in self.agents[i]:                    if len(interp.intersection(fa)) == 0:                        dist1 += 1                    # doute car on regarde pas le nombre de formule ici ??                    dist2 += len(interp.symmetric_difference(fa))                    dist3 += len(interp.intersection(fa))                                # # a = self.agents[i]                # # tmp = len(set([str(sorted(n)) for n in a]).symmetric_difference(set([str(sorted(p)) for p in m])))                # # print(self.maxcons_ind[j], self.agents_ind[i], len(self.maxcons_ind[j].symmetric_difference(set(self.agents_ind[i]))), len(self.maxcons_ind[j].intersection(set(self.agents_ind[i]))))                # # tmp = len(set([str(sorted(n)) for n in a]).intersection(set([str(sorted(p)) for p in m])))                                # a = set()                # for k in range(len(self.agents_ind[i])):                #     if self.formulas_chosed[k]:                #         a.add(self.agents_ind[i][k])                # dist2 += len(set(self.maxcons_ind[j]).symmetric_difference(a))                # inter = len(set(self.maxcons_ind[j]).intersection(a))                # dist3 += inter                                # dist1 += int(len(self.maxcons_ind[j].intersection(set(self.agents_ind[i]))) > 0)                # # consist = False                # # for intp in m:                # #     if intp in a:                # #         consist = True                # #         break                # # if not consist:                # #     dist1 += 1            distance1.append(dist1)            distance2.append(dist2)            distance3.append(dist3)        self.distance.append(distance1)        self.distance.append(distance2)        self.distance.append(distance3)            def gen_agents(self):        # for f in self.formulas:        #     print(f"{f} : {sorted([int(n) for n in list(self.formulas[f])])}")        for s in self.G.sf:            self.agents.append([])            self.agents_ind.append([])            nbf = 0            # rempli agents            for i in range(len(s)):                j = s[i]                if j == 1:                    # if self.formulas_chosed[i]:                    #     self.taille_profile_avg += 1                    self.agents[-1].append(self.formulas[str(nbf)])                    self.agents_ind[-1].append(nbf)                nbf += 1            # calcul        #     self.len_croyance_avg += len(self.agents[-1])        # self.len_croyance_avg = self.len_croyance_avg / len(self.G.sf)        #     self.len_croyance_avg += len(self.agents_to_interp(self.agents[-1]))        # self.len_croyance_avg = self.len_croyance_avg / len(self.G.sf)        # self.taille_profile_avg = self.taille_profile_avg / len(self.G.sf)    def gen_maxcons(self, lst):        """lst : liste avec negation"""        # taille = int(self.len_interpretation / 2) + 1        # -2 car chaque formule fera une taille max de (nb_interp - 2)         taille = self.len_interpretation - 2        if taille <= 0:            taille = 1        # taille = 8        maxcons = []        curr_ind = 0        # print(lst)        for curr_taille in range(1, taille+1):            str_poss, sets_poss = self.dict_all_combi[curr_taille]            # str_poss, sets_poss = self.all_combinations([str(n) for n in self.interpretation], curr_taille)            for i in range(len(str_poss)):                setp = sets_poss[i]                maxcons.append(set())                # print(str_poss[i], setp, maxcons[i])                for j in range(0, len(lst), 2):                    f = lst[j]                    # print(type(setp), type(lst[j+1]), type(f))                    # print(setp, f, setp.issubset(f), setp.issubset(lst[j+1]))                    # if setp.issubset(f):                    #     maxcons[curr_ind].add(j)                    # elif setp.issubset(lst[j+1]):                    #     maxcons[curr_ind].add(j+1)                    if self.formulas_chosed[j] and setp.issubset(f):                        maxcons[curr_ind].add(j)                    elif self.formulas_chosed[j+1] and setp.issubset(lst[j+1]):                        maxcons[curr_ind].add(j+1)                curr_ind += 1        res = []        res_f = []        for i in range(len(maxcons)):            if len(maxcons[i]) > 0:                add = True                smc = sorted(maxcons[i])                for j in range(len(maxcons)):                    # print(i, j)                    if smc != sorted(maxcons[j]):                        if maxcons[i].issubset(maxcons[j]):                            # sous liste                            # print("break", i, j, maxcons[i], maxcons[j])                            add = False                            break                        # print(i, j, maxcons[i], maxcons[j])                # print("add", add, i)                if add:                    if smc not in res:                        res.append(smc)                        res_f.append([lst[smc[v]] for v in range(len(smc))])        # print(datetime.now().strftime('%H:%M:%S:%f'))                   # for i in range(len(res)):        #     print(i, self.maxcons_to_interp(res_f[i]), len(res_f[i]))            # print(i, res[i], res_f[i], self.maxcons_to_interp(res_f[i]))                    return res_f, res    def gen_relia_dict(self):        for i in range(len(self.G.trust_f)):            self.relia[i] = self.G.trust_f[i]            def agents_to_interp(self, m):        """        retourne l'intersection de toutes les formules de l'agent m -> ses croyances        """        inter = None        for i in range(len(m)):            f = m[i]            if self.formulas_chosed[self.formulas_id[str(sorted(f))]]:                if inter == None:                    inter = f                else:                    inter = inter.intersection(f)        if inter == None:            for i in range(len(m)):                f = m[i]                #if self.formulas_chosed[self.formulas_id[str(sorted(f))]]:                if inter == None:                    inter = f                else:                    inter = inter.intersection(f)        return inter        def maxcons_to_interp(self, m):        """        retourne l'intersection de toutes les formules du maxcons m        """        inter = None        for f in m:            if inter == None:                inter = f            else:                inter = inter.intersection(f)        return inter            def dist_bin(self, truth, v):        r = 0        for i in range(len(truth)):            if truth[i] != v[i]:                r += 1        return r        def tobin(self, v):        res = bin(v)[2:]        maxx = bin(self.len_interpretation)[2:]        for i in range(len(maxx) - len(res)):            res = '0' + res        return res                    def resultats(self, ind_decision=None, reprr=None):        # if reprr != None:        #     print()        #     print(reprr)                # print(self.G)        # print(self.G.mem_f)        # print(self.relia)        # print(self.formulas)        self.min_len_maxcons = len(self.maxcons_to_interp(self.maxcons[0]))        # if self.min_len_maxcons < 1:        #     print("pb", self.min_len_maxcons)        #     print(self.maxcons[0])        #     print(self.maxcons_ind[0])        #     sys.exit()                # en nombre de f        # taille_max_maxcons = 0                for i in range(len(self.maxcons)):            # taille_max_maxcons = max(taille_max_maxcons, len(self.maxcons[i]))            # for m in self.maxcons[i]:            inter = self.maxcons_to_interp(self.maxcons[i])            self.truth_in_mc += int(self.truth[0] in inter)            n = len(inter)                        # if n < 1:            #     print("pb", n)            #     print(self.maxcons[i])            #     print(self.maxcons_ind[i])            #     sys.exit()                        self.max_len_maxcons = max(self.max_len_maxcons, n)            self.min_len_maxcons = min(n, self.min_len_maxcons)            self.len_maxcons += n        self.len_maxcons = self.len_maxcons / len(self.maxcons)        self.truth_in_mc = self.truth_in_mc / len(self.maxcons)        nb = 0                # answers doivent etre unanime et correcte        self.formulas_good = 0        tmp_avg_score = 0        truth = self.truth[0]                    if len(self.answers) == 1:            for f in list(self.answers[0]):                if truth in f:                    self.formulas_good += 1                                    tmp_avg_score += 1                self.nb_total2 += 1                # print(truth, f, self.formulas_good)            self.avg_score.append( (tmp_avg_score / self.nb_total2))        else:            # print(self.answers)            tmp_ind = dict()            tmp_n = 0            taille_max_maxcons = len(self.formulas)            for i in range(taille_max_maxcons):                tmp_ind[i] = tmp_n                if i % 2 != 0:                    tmp_n += 1            # print(taille_max_maxcons)            # print(tmp_ind)            # print(self.maxcons)            # print(self.formulas)            tmp_una = [False for n in range(taille_max_maxcons)]            for i in range(0, len(self.answers)):                tmp_avg_score = 0                for j in range(len(list(self.answers[i]))):                    f = self.answers[i][j]                                        isin = int(truth in f)                    tmp_avg_score += isin                    # self.formulas_good += isin                    # self.nb_total2 += 1                    ind = tmp_ind[self.formulas_id[str(sorted(f))]]                    if tmp_una[ind] != False and tmp_una[ind] != f:                        tmp_una[ind] = [None]                self.avg_score.append( tmp_avg_score / len(self.answers[i]))                # print(self.avg_score, tmp_avg_score, truth, self.answers[i])            tmp_una = [n for n in tmp_una if n != False]            self.tmp_una = tmp_una            # print("una", tmp_una)            for i in range(len(tmp_una)):                if truth in tmp_una[i]:                    self.formulas_good += 1                self.nb_total2 += 1                # print(truth, tmp_una[i], self.formulas_good)                        bin_truth = self.tobin(int(self.truth[0]))        for i in range(len(self.answers)):            self.nb_answers += 1            inter = self.maxcons_to_interp(self.answers[i])            self.rep_intp.append(inter)            for intp in inter:                nb += 1                if intp in self.unanimous_answers_dico:                    self.unanimous_answers_dico[intp] += 1                else:                    self.unanimous_answers_dico[intp] = 1                self.intp_bin.append(self.tobin(int(intp)))                self.distance_intp.append(self.dist_bin(bin_truth, self.intp_bin[-1]))                if self.truth[0] == intp:                    self.nb_true_found += 1            self.nb_total += 1                                            for intp in self.unanimous_answers_dico:            if self.unanimous_answers_dico[intp] == nb:                self.nbi_una += 1                self.truth_una += int(self.truth[0] == intp)                self.distance_una += self.dist_bin(bin_truth, self.tobin(int(intp)))                                                                