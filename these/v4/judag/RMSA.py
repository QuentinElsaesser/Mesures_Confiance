# import numpy as np# from v4.graph import graph# from operator import itemgetter# from itertools import groupby# from v4.vote import normalize as nm# from v4.graph import obj# from copy import deepcopyfrom itertools import chain, combinations, productfrom v4.judag import baseVoclass RMSA(baseVo.BaseVoting):    """    Quand la majorité n’est pas cohérente, on enlève le moins     d’elements possible (en terme d’inclusion pas en terme de formule)     pour avoir un ensemble coherent        Dans le modele :        FAIT IMPAIR = FALSE (0) donc fait 1-3-5-etc = false value for formula            MAIS indice pair = true value !!        FAIT PAIR = TRUE (1)    """    def __init__(self, mat_fs, mat_of, voting_met, vote_para, name_norma, nb_s, nb_f, init_trust=1,truth=[],normalizer=None,trust_s=None,trust_f=None,long=False,gobj=None,sf=None,model=[],Gr=None,form=None,vect=None,revres=None,maj_form=None,maj_formSF=None):                super().__init__(mat_fs=mat_fs, mat_of=mat_of, voting_met=voting_met,                          vote_para=vote_para, name_norma=name_norma,                          nb_s=nb_s, nb_f=nb_f, truth=truth, trust_s=trust_s,                         init_trust=init_trust,normalizer=normalizer,                         trust_f=trust_f,long=long,gobj=gobj,sf=sf,                         model=model,Gr=Gr,                         form=form,vect=vect,revres=revres,maj_form=maj_form)        # Si une etoile, faire l'extension cf papier reent        self.nb_litt = len(self.maj_form)                # print("MAJ", self.maj_form)                self.dico = dict()                for i in range(len(self.form)):            f = self.form[i]            for p in f:                if p in self.dico:                    self.dico[p].append((i,f))                else:                    self.dico[p] = [(i,f)]                        def indx_asso(self, f):        indx = []        for i in range(len(f)):            if "*" not in f[i]:                if f[i][0] == 'n':                    indx.append(int(f[i][1:])-1)                else:                    indx.append(int(f[i])-1)            else:                indx.append(int(f[i][1:])-1)        return indx        def max_cons(self, f, indxs):        for n in self.dico[f[0]]:            ok = True            for i in range(len(indxs)):                indx = indxs[i]                if f[i] != n[1][indx]:                    ok = False                    # print(n, f, i, indx, f[i], n[1][indx])                    break            if ok:                return True,n        return False,None        def gen_poss_stars(self, f):        nbs = 0        for n in f:            if "*" in n:                nbs += 1        nb = list(product([1,0],repeat=nbs))                res = [[] for n in range(len(nb))]        for i in range(len(nb)):            curr = 0            for j in range(len(f)):                if "*" in f[j]:                    if nb[i][curr]:                        res[i].append(f[j].replace("*",""))                        curr += 1                    else:                        res[i].append(f[j].replace("*","n"))                        curr += 1                else:                    res[i].append(f[j])        return res                    def aggr(self):        """        On teste pour la premire formule et on fait l'unionn des distances mini         pour la formule lorsque formule 1 à vrai et         lorsque la formule 1 à faux entre le tabke et la majortié        et on repete pour toutes les formules        """        # self.results([0,-1], self.__repr__)        sub = []        res = []        spe_form = []        stars = False        # if "*" in self.maj_form:        for n in self.maj_form:            if "*" in n:                stars = True            spe_form.append(n)        # else:        #     spe_form = self.maj_form                for i in range(self.nb_litt, 0, -1):            # print("subset of ",i,"elts")            for f in combinations(spe_form, i):                if stars:                    # print("stars in ",f)                    for f2 in self.gen_poss_stars(f):                        f = f2                        include = False                        # include_n = None                        for n in sub:                            # print("subset ?", f,n)                            if set(f).issubset(set(n)):                                include = True                                # include_n = n                                break                        if not include:                            indx = self.indx_asso(f)                            cons,form = self.max_cons(f, indx)                            if cons:                                sub.append(f)                                res.append(form)                            # print("--", f, indx, "coherent:", cons)                            # print()                        # else:                            # print("SUBSET OF res", f, include, include_n)                  else:                    include = False                    # include_n = None                    for n in sub:                        # print("subset ?", f,n)                        if set(f).issubset(set(n)):                            include = True                            # include_n = n                            break                    if not include:                        indx = self.indx_asso(f)                        cons,form = self.max_cons(f, indx)                        if cons:                            sub.append(f)                            res.append(form)                        # print("--", f, indx, "coherent:", cons)                        # print()                    # else:                        # print("SUBSET OF res", f, include, include_n)          for s in sub:            for n in self.dico[s[0]]:                b = set(s).issubset(set(n[1]))                # print(n,s, b)                if b:                    if n not in res:                        res.append(n)                    # print("Chercher les reponses selon les max cons")        # for n in res:        #     print("MSA", n)                self.results([res[i][0] for i in range(len(res))], self.__repr__)        