# import numpy as np# from v4.graph import graph# from operator import itemgetter# from itertools import groupby# from v4.vote import normalize as nm# from v4.graph import objfrom copy import deepcopyfrom v4.judag import baseVoclass RRA(baseVo.BaseVoting):    """    Ordonne chaque formule de l’agenda et on considère que celle     qui ont plus que la moitié des votes et on les classe dans l’ordre     décroissant et on ajoute de façon séquentielle (si c’est cohérent)        Dans le modele :        FAIT IMPAIR = FALSE (0) donc fait 1-3-5-etc = false value for formula            MAIS indice pair = true value !!        FAIT PAIR = TRUE (1)    """    def __init__(self, mat_fs, mat_of, voting_met, vote_para, name_norma, nb_s, nb_f, init_trust=1,truth=[],normalizer=None,trust_s=None,trust_f=None,long=False,gobj=None,sf=None,model=[],Gr=None,form=None,vect=None,revres=None,maj_form=None,maj_formSF=None):                super().__init__(mat_fs=mat_fs, mat_of=mat_of, voting_met=voting_met,                          vote_para=vote_para, name_norma=name_norma,                          nb_s=nb_s, nb_f=nb_f, truth=truth, trust_s=trust_s,                         init_trust=init_trust,normalizer=normalizer,                         trust_f=trust_f,long=long,gobj=gobj,sf=sf,                         model=model,Gr=Gr,                         form=form,vect=vect,revres=revres,maj_form=maj_form)                self.thresh = len(self.G.sf) / 2            def remove_one_formula(self, liste, formula):        if type(formula) == list:            res = []            index = self.toint(formula[0])-1            # print("formule", formula, "index de la formule", index)            for lt in liste:                if lt[index] == formula[0] or lt[index] == formula[1]:                    res.append(lt)            return res        else:            res = []            index = self.toint(formula)-1            # print("formule", formula, "index de la formule", index)            for lt in liste:                if lt[index] == formula:                    res.append(lt)            return res            def remove_form(self, liste, formula):        """        remove les elements ou formula n'est pas present        Si egalité, on fait l'union pour tous         si tous les objets sont dans formula = on a toutes les possibilites coherentes        """        res = []        tmp = deepcopy(liste)        # print(f"supp les formules ou {formula} pas present")        if len(formula) > 1:            # print("egalite")            # tres = []            for f in formula:                tab = self.remove_one_formula(tmp, f)                # print("--", f, tab)                if len(tab) != 0:                    tmp = tab            res = tmp                # tab = self.remove_one_formula(tmp, f)                # print("--", f, tab)                # for n in tab:                #     if n not in tres:                #         tres.append(n)            # res = tres        else:            res = self.remove_one_formula(tmp, formula[0])        if len(res) == 0:            # print("res vide donc on garde", liste)            return liste        return res            def toint(self, m):        if m[0] == 'n':            return int(str(m[1:]))        return int(m)            def aggr(self):         dico = dict()        for i in range(len(self.G.obj.of)):            o = self.G.obj.of[i]            t0 = o.prec[0].trust            t1 = o.prec[1].trust            if t0 == t1:                if t0 in dico:                    dico[t0].append([str(i+1), "n"+str(i+1)])                else:                    dico[t0] = [[str(i+1), "n"+str(i+1)]]            else:                            if t0 > self.thresh:                    if t0 in dico:                        dico[t0].append("n"+str(i+1))                    else:                        dico[t0] = ["n"+str(i+1)]                if t1 > self.thresh:                    if t1 in dico:                        dico[t1].append(str(i+1))                    else:                        dico[t1] = [str(i+1)]        # dico -> trust : [objet] pour la majorite        # print("threshold", self.thresh)                # print("dico -> trust : [objet] pour la majorite")        # print(dico)        tmp = deepcopy(self.form)        sort = sorted(list(dico.keys()), reverse=True)                # for i in range(len(tmp)):        #     print(i, tmp[i])        # print()                for currind, s in enumerate(sort):            # print(currind, s, dico[s])                        tmp = self.remove_form(tmp, dico[sort[currind]])                                # print("currind", currind)            # for l in tmp:            #     print(l)            # print()                        if len(tmp) == 1:                break                # while(currind < len(sort) and len(tmp) > 1):        #     tmp = self.remove_form(tmp, dico[sort[currind]])                    #     print("currind", currind)        #     for l in tmp:        #         print(l)        #     print()                    #     currind += 1        self.results([self.form.index(tmp[i]) for i in range(len(tmp))], self.__repr__)        